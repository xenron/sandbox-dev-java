
package tuning.profview;

/**
 * This class was generated by a SmartGuide.
 *
 */
public class ProfileStack
{
	ProfileLine[] stack;
	ProfileCalleeAggregate[] aggs;
	boolean timeSorted;
	int totalTime;
	int totalCount;
	private static final char[] charForDigit = {
		'0','1','2','3','4','5','6','7','8','9'
	};

    public static void main(String[] args)
    {
        try
        {
            if (args[0].equals("-c"))
                cumulativeTimeReport(reduce_args(args,1));
            else
                diffTimeReport(args);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

public static String[] reduce_args(String[] args, int reduction)
{
    String[] new_args = new String[args.length - reduction];
    System.arraycopy(args,reduction,new_args,0,new_args.length);
    return new_args;
}

public static void diffTimeReport(String[] args)
    throws java.io.IOException
{
    ProfileStack p = new ProfileStack(args[0]);
    p.setDiffTimes();
    p.sortOnTime();
    p.sortAggOnDiffTime(0,p.aggs.length - 1);
    System.out.println(p.toAggregateString());
}

public static void cumulativeTimeReport(String[] args)
    throws java.io.IOException
{
    ProfileStack p = new ProfileStack(args[0]);
    p.setDiffTimes();
    p.sortOnTime();
    System.out.println(p.toAggregateString());
}

public void setDiffTimes()
{
    java.util.Hashtable callees = new java.util.Hashtable();
	for (int i = aggs.length - 1; i >= 0; i--)
	{
		callees.put(aggs[i].callee.method, aggs[i]);
	}
	
	int j;
	ProfileCallerAggregate caller;
	ProfileCalleeAggregate callee;
	for (int i = aggs.length - 1; i >= 0; i--)
	{
		
		for (j = aggs[i].aggs.length - 1; j >= 0; j--)
		{
		    caller = aggs[i].aggs[j];
		    callee = (ProfileCalleeAggregate) callees.get(caller.caller.method);
		    if (callee != null)
		        callee.diffTime -= caller.time;
		}
	}
}

void sortAggOnDiffTime(int lo, int hi)
{
	if( lo >= hi )
		return;

	int mid = ( lo + hi ) / 2;
	ProfileCalleeAggregate tmp;
	ProfileCalleeAggregate middle = aggs[ mid ];

	if( aggs[ lo ].diffTime > middle.diffTime)
	{
		aggs[ mid ] = aggs[ lo ];
		aggs[ lo ] = middle;
		middle = aggs[ mid ];
	}

	if( middle.diffTime > aggs[hi].diffTime)
	{
		aggs[ mid ] = aggs[ hi ];
		aggs[ hi ] = middle;
		middle = aggs[ mid ];

		if( aggs[ lo ].diffTime > middle.diffTime)
		{
			aggs[ mid ] = aggs[ lo ];
			aggs[ lo ] = middle;
			middle = aggs[ mid ];
		}
	}

	int left = lo + 1;
	int right = hi - 1;

	if( left >= right )
		return;

	for( ;; )
	{
		while( aggs[ right ].diffTime >  middle.diffTime)
		{
			right--;
		}

		while( left < right && aggs[ left ].diffTime <= middle.diffTime)
		{
			left++;
		}

		if( left < right )
		{
			tmp = aggs[ left ];
			aggs[ left ] = aggs[ right ];
			aggs[ right ] = tmp;
			right--;
		}
		else
		{
			break;
		}
	}

	sortAggOnDiffTime(lo, left);
	sortAggOnDiffTime(left + 1, hi);
}
/**
 * This method was created by a SmartGuide.
 * @param filename java.lang.String
 */
public ProfileStack(String filename)
	throws java.io.IOException
{
	java.io.BufferedReader r = new java.io.BufferedReader(new java.io.FileReader(filename));
	r.readLine();
	String line;
	java.util.Vector v = new java.util.Vector();
	while( (line = r.readLine()) != null && !line.startsWith("handles_used:"))
		v.addElement(new ProfileLine(line));
	r.close();
	int size = v.size();
	stack = new ProfileLine[size];
	for (int i = 0; i < size; i++)
		stack[i] = (ProfileLine) v.elementAt(i);
	aggregateCallees();
	sortOnTime();
}
/**
 * This method was created by a SmartGuide.
 */
void aggregateCallees()
{
	java.util.Hashtable hash = new java.util.Hashtable();
	String key;
	ProfileCalleeAggregate agg;
	for (int i = 0; i < stack.length; i++)
	{
		key = stack[i].callee.method;
		if ( (agg = (ProfileCalleeAggregate) hash.get(key)) == null)
		{
			agg = new ProfileCalleeAggregate(stack[i]);
			hash.put(key, agg);
		}
		else
			agg.add(stack[i]);
	}
	aggs = new ProfileCalleeAggregate[hash.size()];
	int idx = 0;
	totalTime = 0;
	totalCount = 0;
	java.util.Enumeration e = hash.elements();
	while(e.hasMoreElements())
	{
		aggs[idx] = (ProfileCalleeAggregate) e.nextElement();
		aggs[idx].aggregationIsFinished();
		totalTime += aggs[idx].time;
		totalCount += aggs[idx].count;
		idx++;
	}
}
static void appendPercent(StringBuffer s, long percent, long total)
{
	long i = total > 0 ? (percent * 1000) / total : 0 ;
	int mag=0;
	if (i == 0)
	{
		s.append("0.0");
		return;
	}
	else if (i < 0)
	{
		s.append("-?");
		return;
	}
	else if (i < 10)
	{
		s.append('0');
		mag = 1;
	}
	else if (i < 100)
		mag = 10;
	else if (i < 1000)
		mag = 100;
	else if (i == 1000)
	{
		s.append("100.0");
		return;
	}
	else
	{
		s.append("??");
		return;
	}
	long c;
	while ( mag > 1 )
	{
		c = i/mag;
		s.append(charForDigit[(int) c]);
		c *= mag;
		if ( c <= i)
			i -= c;
		mag = mag/10;
	}
	s.append('.');
	if (i < 0) 
	    System.out.println();
	s.append(charForDigit[(int) i]);
	return;
}
/**
 * This method was created by a SmartGuide.
 */
void sortAggOnCount(int lo, int hi)
{
	if( lo >= hi )
		return;

	int mid = ( lo + hi ) / 2;
	ProfileCalleeAggregate tmp;
	ProfileCalleeAggregate middle = aggs[ mid ];

	if( aggs[ lo ].count > middle.count)
	{
		aggs[ mid ] = aggs[ lo ];
		aggs[ lo ] = middle;
		middle = aggs[ mid ];
	}

	if( middle.count > aggs[hi].count)
	{
		aggs[ mid ] = aggs[ hi ];
		aggs[ hi ] = middle;
		middle = aggs[ mid ];

		if( aggs[ lo ].count > middle.count)
		{
			aggs[ mid ] = aggs[ lo ];
			aggs[ lo ] = middle;
			middle = aggs[ mid ];
		}
	}

	int left = lo + 1;
	int right = hi - 1;

	if( left >= right )
		return;

	for( ;; )
	{
		while( aggs[ right ].count >  middle.count)
		{
			right--;
		}

		while( left < right && aggs[ left ].count <= middle.count)
		{
			left++;
		}

		if( left < right )
		{
			tmp = aggs[ left ];
			aggs[ left ] = aggs[ right ];
			aggs[ right ] = tmp;
			right--;
		}
		else
		{
			break;
		}
	}

	sortAggOnCount(lo, left);
	sortAggOnCount(left + 1, hi);
}
/**
 * This method was created by a SmartGuide.
 */
void sortAggOnTime(int lo, int hi)
{
	if( lo >= hi )
		return;

	int mid = ( lo + hi ) / 2;
	ProfileCalleeAggregate tmp;
	ProfileCalleeAggregate middle = aggs[ mid ];

	if( aggs[ lo ].time > middle.time)
	{
		aggs[ mid ] = aggs[ lo ];
		aggs[ lo ] = middle;
		middle = aggs[ mid ];
	}

	if( middle.time > aggs[hi].time)
	{
		aggs[ mid ] = aggs[ hi ];
		aggs[ hi ] = middle;
		middle = aggs[ mid ];

		if( aggs[ lo ].time > middle.time)
		{
			aggs[ mid ] = aggs[ lo ];
			aggs[ lo ] = middle;
			middle = aggs[ mid ];
		}
	}

	int left = lo + 1;
	int right = hi - 1;

	if( left >= right )
		return;

	for( ;; )
	{
		while( aggs[ right ].time >  middle.time)
		{
			right--;
		}

		while( left < right && aggs[ left ].time <= middle.time)
		{
			left++;
		}

		if( left < right )
		{
			tmp = aggs[ left ];
			aggs[ left ] = aggs[ right ];
			aggs[ right ] = tmp;
			right--;
		}
		else
		{
			break;
		}
	}

	sortAggOnTime(lo, left);
	sortAggOnTime(left + 1, hi);
}
/**
 * This method was created by a SmartGuide.
 */
public void sortOnCount()
{
	sortOnCount(0,stack.length - 1);
	sortAggOnCount(0,aggs.length - 1);
	for (int i = aggs.length - 1; i >= 0; i--)
	{
		aggs[i].sortOnCount();
	}
	timeSorted = false;
}
/**
 * This method was created by a SmartGuide.
 */
void sortOnCount(int lo, int hi)
{
	if( lo >= hi )
		return;

	int mid = ( lo + hi ) / 2;
	ProfileLine tmp;
	ProfileLine middle = stack[ mid ];

	if( stack[ lo ].count > middle.count)
	{
		stack[ mid ] = stack[ lo ];
		stack[ lo ] = middle;
		middle = stack[ mid ];
	}

	if( middle.count > stack[hi].count)
	{
		stack[ mid ] = stack[ hi ];
		stack[ hi ] = middle;
		middle = stack[ mid ];

		if( stack[ lo ].count > middle.count)
		{
			stack[ mid ] = stack[ lo ];
			stack[ lo ] = middle;
			middle = stack[ mid ];
		}
	}

	int left = lo + 1;
	int right = hi - 1;

	if( left >= right )
		return;

	for( ;; )
	{
		while( stack[ right ].count >  middle.count)
		{
			right--;
		}

		while( left < right && stack[ left ].count <= middle.count)
		{
			left++;
		}

		if( left < right )
		{
			tmp = stack[ left ];
			stack[ left ] = stack[ right ];
			stack[ right ] = tmp;
			right--;
		}
		else
		{
			break;
		}
	}

	sortOnCount(lo, left);
	sortOnCount(left + 1, hi);
}
/**
 * This method was created by a SmartGuide.
 */
public void sortOnTime()
{
	sortOnTime(0,stack.length - 1);
	sortAggOnTime(0,aggs.length - 1);
	for (int i = aggs.length - 1; i >= 0; i--)
	{
		aggs[i].sortOnTime();
	}
	timeSorted = true;
}
/**
 * This method was created by a SmartGuide.
 */
void sortOnTime(int lo, int hi)
{
	if( lo >= hi )
		return;

	int mid = ( lo + hi ) / 2;
	ProfileLine tmp;
	ProfileLine middle = stack[ mid ];

	if( stack[ lo ].time > middle.time)
	{
		stack[ mid ] = stack[ lo ];
		stack[ lo ] = middle;
		middle = stack[ mid ];
	}

	if( middle.time > stack[hi].time)
	{
		stack[ mid ] = stack[ hi ];
		stack[ hi ] = middle;
		middle = stack[ mid ];

		if( stack[ lo ].time > middle.time)
		{
			stack[ mid ] = stack[ lo ];
			stack[ lo ] = middle;
			middle = stack[ mid ];
		}
	}

	int left = lo + 1;
	int right = hi - 1;

	if( left >= right )
		return;

	for( ;; )
	{
		while( stack[ right ].time >  middle.time)
		{
			right--;
		}

		while( left < right && stack[ left ].time <= middle.time)
		{
			left++;
		}

		if( left < right )
		{
			tmp = stack[ left ];
			stack[ left ] = stack[ right ];
			stack[ right ] = tmp;
			right--;
		}
		else
		{
			break;
		}
	}

	sortOnTime(lo, left);
	sortOnTime(left + 1, hi);
}
/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String toAggregateString()
{
	StringBuffer s = new StringBuffer();
	String lf = System.getProperty("line.separator");
	s.append("%\t");
	s.append(timeSorted ? "time\tcount" : "count\ttime").append("\tlocaltime\tcallee");
	s.append(lf);
	for (int i = aggs.length - 1; i >= 0; i--)
	{
		if (timeSorted)
			appendPercent(s,aggs[i].time,totalTime);
		else
			appendPercent(s,aggs[i].count,totalCount);
		s.append('\t');
		aggs[i].appendTo(s,timeSorted);
		s.append(lf);
	}
	return s.toString();
}
/**
 * This method was created by a SmartGuide.
 * @return java.lang.String
 */
public String toListString()
{
	StringBuffer s = new StringBuffer();
	String lf = System.getProperty("line.separator");
	s.append("%\t");
	s.append(timeSorted ? "time\tcount" : "count\ttime").append("\tlocaltime\tcallee\tcaller");
	s.append(lf);
	for (int i = stack.length - 1; i >= 0; i--)
	{
		if (timeSorted)
			appendPercent(s,stack[i].time,totalTime);
		else
			appendPercent(s,stack[i].count,totalCount);
		s.append('\t');
		stack[i].appendTo(s,timeSorted);
		s.append(lf);
	}
	s.append(lf);
	return s.toString();
}
}